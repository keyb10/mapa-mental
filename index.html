<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Mental Interativo com Notas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; 
        }
        .node {
            cursor: grab;
            fill: #f0f0f0; 
            stroke: #333; 
            stroke-width: 1.5px;
            border-radius: 8px; 
        }
        .node-text {
            font-size: 14px;
            fill: #333; 
            text-anchor: middle; 
            dominant-baseline: middle; 
            pointer-events: none; 
            user-select: none; 
        }
        .node-text-root { 
            font-weight: bold;
            font-size: 16px; 
        }
        .node.selected {
            stroke: #007bff; 
            stroke-width: 3px;
        }
        .line {
            stroke: #666; 
            stroke-width: 2px;
            fill: none; 
        }
        .note-icon {
            fill: #007bff;
            cursor: pointer;
            stroke: white;
            stroke-width: 0.5px;
        }
        .note-icon:hover {
            fill: #0056b3;
        }

        /* Painel de Comandos */
        .controls {
            position: fixed;
            top: 20px; 
            left: 20px;
            background-color: rgba(255, 255, 255, 0.95); 
            padding: 20px; 
            border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2); 
            z-index: 1000;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            margin-top: 50px; 
        }
        .controls.hidden { 
            transform: translateX(-110%); 
            opacity: 0;
            pointer-events: none; 
        }

        .control-button, .file-input-label {
            background-color: #007bff;
            color: white;
            padding: 10px 18px; 
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            width: 100%; 
            text-align: center;
            display: block; 
        }
        .control-button:hover, .file-input-label:hover {
            background-color: #0056b3;
        }
        .control-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .control-input {
            padding: 10px; 
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px; 
            width: 100%; 
        }
        .message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1001;
            display: none; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .message-box.error {
            background-color: #f44336; 
        }
        #mindMapContainer {
            width: 100%;
            height: 100vh; 
            overflow: hidden; 
            background-color: #f9f9f9; 
            position: relative;
        }
        #mindMapSvg {
            width: 100%;
            height: 100%;
            display: block;
        }
        #toggleMenuBtn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1005; 
            background-color: #007bff; 
            color: white; 
            border: none;
            border-radius: 8px; 
            padding: 8px; 
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex; 
            align-items: center;
            justify-content: center;
            width: 40px; 
            height: 40px; 
        }
        #toggleMenuBtn:hover {
            background-color: #0056b3;
        }
        #toggleMenuBtn svg {
            width: 24px; 
            height: 24px;
        }

        /* Painel de Notas */
        #notesPanel {
            position: fixed;
            right: 0; 
            top: 0;
            width: 35%; 
            max-width: 500px; 
            min-width: 300px; 
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1); 
            z-index: 1010; 
            transform: translateX(100%); 
            transition: transform 0.3s ease-in-out;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        #notesPanel.visible {
            transform: translateX(0); 
        }
        .notes-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #notesPanel h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
            margin: 0; 
        }
        #closeNotesIcon {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
         #closeNotesIcon svg {
            width: 20px;
            height: 20px;
            stroke: #555;
        }
        #closeNotesIcon:hover svg {
            stroke: #000;
        }

        #noteTextArea {
            width: 100%;
            height: 200px; 
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 10px;
            font-size: 14px; 
            font-family: 'Inter', sans-serif; 
            margin-bottom: 15px;
            resize: vertical; 
        }
        .notes-toolbar label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.875rem;
            color: #555;
        }
        .notes-toolbar input[type="text"], .notes-toolbar input[type="file"] { 
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 0.875rem;
        }
        #imagePreview {
            max-width: 100%;
            max-height: 150px;
            margin-top: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            object-fit: contain;
            border: 1px solid #eee;
        }
        .notes-actions { 
            margin-top: auto; 
            padding-top: 15px; 
        }
        .node-edit-input {
            width: 100%;
            height: 100%;
            border: none; 
            padding: 0;
            margin: 0;
            background: transparent;
            text-align: center;
            font-family: 'Inter', sans-serif;
            font-size: 14px; 
            color: #333;
            outline: 1px solid #007bff; 
            box-sizing: border-box; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .node-edit-input-root { 
            font-weight: bold;
            font-size: 16px;
        }
        /* Menu de Contexto Personalizado */
        .custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1020; 
            display: none; 
        }
        .custom-context-menu-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .custom-context-menu-list li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .custom-context-menu-list li:hover {
            background-color: #f0f0f0;
        }
        #openMapInput {
            display: none;
        }

    </style>
</head>
<body class="bg-gray-100">

    <button id="toggleMenuBtn" title="Alternar Menu"></button>

    <div id="mindMapContainer">
        <svg id="mindMapSvg"></svg>
    </div>

    <div id="controlsMenu" class="controls space-y-4 hidden"> 
        <div>
            <input type="text" id="nodeText" class="control-input" placeholder="Texto para Nó Raiz/Filho">
            <button id="addNodeBtn" class="control-button">Adicionar Nó Raiz</button>
        </div>
        <div> 
            <button id="addChildBtn" class="control-button" disabled>Adicionar Filho</button>
        </div>
        <div>
            <button id="editNodeBtn" class="control-button" disabled>Editar Nó</button> 
        </div>
        <div> 
            <button id="deleteNodeBtn" class="control-button" disabled>Eliminar Nó</button>
        </div>
        <div> 
            <button id="addEditNoteBtn" class="control-button" disabled>Adicionar/Editar Nota</button>
        </div>
        <hr class="my-3 border-gray-300"> <div>
            <button id="saveMapBtn" class="control-button bg-green-500 hover:bg-green-600">Salvar Mapa</button>
        </div>
        <div>
            <input type="file" id="openMapInput" accept=".json">
            <label for="openMapInput" class="file-input-label bg-blue-500 hover:bg-blue-600">Abrir Mapa</label>
        </div>
        <hr class="my-3 border-gray-300"> <div class="text-sm text-gray-700 pt-2"> 
            <span class="font-semibold">Nó Selecionado:</span>
            <span id="selectedNodeDisplay" class="block mt-1 p-2 bg-gray-100 rounded">Nenhum</span> 
        </div>
        <div class="text-xs text-gray-500 pt-2"> 
            Clique duas vezes num nó para editar o texto. <br>
            Clique direito num nó para mais opções. <br>
            Use o scroll do rato para zoom. <br>Clique e arraste o fundo para mover.
        </div>
    </div>

    <div id="notesPanel">
        <div class="notes-panel-header">
            <h3>Editar Nota do Nó</h3>
            <button id="closeNotesIcon" title="Fechar Painel de Notas">
                </button>
        </div>
        <div class="notes-toolbar space-y-3">
            <div>
                <label for="noteTextArea">Texto da Nota:</label>
                <textarea id="noteTextArea"></textarea>
            </div>
            <div>
                <label for="noteImageUrl">URL da Imagem:</label>
                <input type="text" id="noteImageUrl" placeholder="Cole o URL da imagem aqui">
                <img id="imagePreview" src="#" alt="Pré-visualização da imagem" style="display:none;">
            </div>
            <div>
                <label for="noteDocumentName">Nome do Documento Anexado:</label>
                <input type="text" id="noteDocumentName" placeholder="Ex: relatorio.pdf">
            </div>
        </div>
        <div class="notes-actions">
            </div>
    </div>

    <div id="messageBox" class="message-box">Mensagem</div>

    <div id="customContextMenu" class="custom-context-menu">
        <ul class="custom-context-menu-list">
            <li id="contextAddChild">Adicionar Filho</li>
            <li id="contextEditNode">Editar Nó</li>
            <li id="contextAddEditNote">Adicionar/Editar Nota</li> 
            <li id="contextDeleteNode">Eliminar Nó</li>
        </ul>
    </div>


    <script>
        // --- Elementos da UI ---
        const svg = document.getElementById('mindMapSvg');
        const nodeTextInput = document.getElementById('nodeText'); 
        const addNodeBtn = document.getElementById('addNodeBtn');
        const addChildBtn = document.getElementById('addChildBtn'); 
        const editNodeBtn = document.getElementById('editNodeBtn');   
        const deleteNodeBtn = document.getElementById('deleteNodeBtn'); 
        const addEditNoteBtn = document.getElementById('addEditNoteBtn'); 
        const selectedNodeDisplay = document.getElementById('selectedNodeDisplay');
        const messageBox = document.getElementById('messageBox');
        const mindMapContainer = document.getElementById('mindMapContainer');
        const toggleMenuBtn = document.getElementById('toggleMenuBtn');
        const controlsMenu = document.getElementById('controlsMenu');
        const saveMapBtn = document.getElementById('saveMapBtn'); 
        const openMapInput = document.getElementById('openMapInput'); 

        // Elementos do Painel de Notas
        const notesPanel = document.getElementById('notesPanel');
        const noteTextArea = document.getElementById('noteTextArea');
        const noteImageUrl = document.getElementById('noteImageUrl');
        const imagePreview = document.getElementById('imagePreview');
        const noteDocumentName = document.getElementById('noteDocumentName');
        const closeNotesIcon = document.getElementById('closeNotesIcon'); 
        let currentlyEditingNodeId = null; 
        let editingNodeTextId = null; 

        // Elementos do Menu de Contexto
        const customContextMenu = document.getElementById('customContextMenu');
        const contextAddChildBtn = document.getElementById('contextAddChild');
        const contextEditNodeBtn = document.getElementById('contextEditNode'); 
        const contextAddEditNoteBtn = document.getElementById('contextAddEditNote'); 
        const contextDeleteNodeBtn = document.getElementById('contextDeleteNode');


        // --- Ícones SVG ---
        const hamburgerIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
        const closeIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
        const noteIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" class="note-indicator-icon"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`;
        const panelCloseIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;


        // --- Estado do Mapa Mental ---
        let nodes = [];
        let lines = []; 
        let selectedNodeId = null;
        let nextNodeId = 0;
        let isDraggingNode = false;
        let dragOffsetX, dragOffsetY;
        let draggedNodeElement = null;
        let viewBox = { x: 0, y: 0, w: mindMapContainer.clientWidth, h: mindMapContainer.clientHeight };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };

        // --- Inicialização ---
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
        toggleMenuBtn.innerHTML = hamburgerIconSVG; 
        closeNotesIcon.innerHTML = panelCloseIconSVG; 

        // --- Funções Auxiliares ---
        function isInputFocused() {
            const activeElement = document.activeElement;
            // console.log('Active element for isInputFocused:', activeElement); // DEBUG
            if (!activeElement) return false;
            const tagName = activeElement.tagName.toLowerCase();
            return (tagName === 'input' || tagName === 'textarea' || activeElement.isContentEditable);
        }

        // --- Event Listeners ---
        toggleMenuBtn.addEventListener('click', () => {
            controlsMenu.classList.toggle('hidden');
            toggleMenuBtn.innerHTML = controlsMenu.classList.contains('hidden') ? hamburgerIconSVG : closeIconSVG;
            toggleMenuBtn.title = controlsMenu.classList.contains('hidden') ? "Abrir Comandos" : "Fechar Comandos";
            hideCustomContextMenu(); 
        });

        addEditNoteBtn.addEventListener('click', () => {
            if (selectedNodeId !== null) {
                openNotesPanel(selectedNodeId);
            } else {
                showMessage('Por favor, selecione um nó primeiro para adicionar ou editar uma nota.', 'error');
            }
        });
        
        // Listeners para os botões do menu principal
        addNodeBtn.addEventListener('click', () => {
            // console.log('Add Root Node button clicked'); // DEBUG
            const text = nodeTextInput.value.trim(); 
            if (nodes.some(n => n.isRoot)) {
                showMessage('Já existe um nó raiz.', 'error'); return;
            }
            const finalText = text === "" ? "Nó Raiz" : text;

            const initialX = viewBox.x + viewBox.w / 2 - 100; 
            const initialY = viewBox.y + viewBox.h / 2 - 30; 
            const newNode = createNode(finalText, initialX, initialY, null, true); 
            if (newNode) {
                selectedNodeId = newNode.id; 
                nodeTextInput.value = ''; 
                if (document.activeElement === nodeTextInput) { 
                    nodeTextInput.blur(); 
                }
                updateLines(); 
                renderMindMap(); 
                showMessage(`Nó "${newNode.text}" adicionado como raiz.`);
            }
        });

        addChildBtn.addEventListener('click', () => {
            // console.log('Add Child button clicked. Selected Node ID:', selectedNodeId); // DEBUG
            if (selectedNodeId === null) {
                showMessage('Selecione um nó pai primeiro.', 'error');
                return;
            }
            const parentNode = nodes.find(n => n.id === selectedNodeId);
            if (!parentNode) {
                // console.error('Add Child: Parent node not found with ID', selectedNodeId); // DEBUG
                showMessage('Nó pai não encontrado.', 'error');
                return;
            }

            const text = nodeTextInput.value.trim(); 
            if (text === "") {
                 showMessage('Por favor, introduza o texto para o nó filho no campo acima.', 'error');
                 nodeTextInput.focus(); 
                 return;
            }
            
            const childrenCount = parentNode.childrenIds.length;
            const angleStep = Math.PI / (childrenCount + 3); 
            const initialAngleOffset = -Math.PI / 2; 
            const baseDistance = (parentNode.isRoot ? 150 : 100) + childrenCount * 15; 
            const angle = initialAngleOffset + (childrenCount * angleStep) + (Math.random() * 0.2 - 0.1) ; 
            const childX = parentNode.x + parentNode.width / 2 - 50 + Math.cos(angle) * baseDistance;
            const childY = parentNode.y + parentNode.height / 2 - 20 + Math.sin(angle) * baseDistance;

            const newNode = createNode(text, childX, childY, selectedNodeId);
            if (newNode) {
                nodeTextInput.value = ''; 
                updateLines();
                renderMindMap();
                showMessage(`Nó "${text}" adicionado como filho de "${parentNode.text}".`);
            }
        });

        editNodeBtn.addEventListener('click', () => {
            // console.log('Edit Node button clicked. Selected Node ID:', selectedNodeId); // DEBUG
            if (selectedNodeId === null) {
                showMessage('Nenhum nó selecionado para editar.', 'error');
                return;
            }
            const nodeToEdit = nodes.find(n => n.id === selectedNodeId);
            if (nodeToEdit) {
                enterNodeTextEditMode(nodeToEdit.id);
            }
        });

        deleteNodeBtn.addEventListener('click', () => {
            // console.log('Delete Node button clicked. Selected Node ID:', selectedNodeId); // DEBUG
            attemptDeleteSelectedNode(); 
        });


        // Função para salvar dados da nota automaticamente
        function autoSaveNoteData() {
            if (currentlyEditingNodeId === null) return;
            const node = nodes.find(n => n.id === currentlyEditingNodeId);
            if (node) {
                const oldNoteEmpty = !node.notes.text && !node.notes.imageUrl && !node.notes.documentName;

                node.notes.text = noteTextArea.value;
                node.notes.imageUrl = noteImageUrl.value.trim();
                node.notes.documentName = noteDocumentName.value.trim();
                
                const newNoteEmpty = !node.notes.text && !node.notes.imageUrl && !node.notes.documentName;

                if (oldNoteEmpty !== newNoteEmpty) {
                    renderMindMap(); 
                }
            }
        }

        // Funções do Painel de Notas
        noteTextArea.addEventListener('input', autoSaveNoteData);
        noteImageUrl.addEventListener('input', () => {
            if (noteImageUrl.value.trim() !== '') {
                imagePreview.src = noteImageUrl.value;
                imagePreview.style.display = 'block';
            } else {
                imagePreview.style.display = 'none';
            }
            autoSaveNoteData(); 
        });
        noteDocumentName.addEventListener('input', autoSaveNoteData);

        imagePreview.onerror = () => { 
            imagePreview.style.display = 'none'; 
        };

        closeNotesIcon.addEventListener('click', closeNotesPanel); 

        function openNotesPanel(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            currentlyEditingNodeId = nodeId;
            noteTextArea.value = node.notes.text;
            noteImageUrl.value = node.notes.imageUrl;
            noteDocumentName.value = node.notes.documentName;

            imagePreview.style.display = node.notes.imageUrl ? 'block' : 'none';
            if (node.notes.imageUrl) imagePreview.src = node.notes.imageUrl;
            notesPanel.classList.add('visible');
        }

        function closeNotesPanel() {
            notesPanel.classList.remove('visible');
            currentlyEditingNodeId = null;
        }

        // --- Funções do Menu de Contexto ---
        function showCustomContextMenu(x, y, nodeId) {
            // console.log(`[SHOW_CONTEXT_MENU] For Node ID: ${nodeId} at (${x}, ${y})`); // DEBUG
            customContextMenu.style.left = `${x}px`;
            customContextMenu.style.top = `${y}px`;
            customContextMenu.style.display = 'block';
            customContextMenu.dataset.targetNodeId = nodeId; 
        }

        function hideCustomContextMenu() {
            if (customContextMenu.style.display === 'block') {
                // console.log('[HIDE_CONTEXT_MENU] Hiding context menu.'); // DEBUG
                customContextMenu.style.display = 'none';
            }
        }

        contextAddChildBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            // console.log('[CONTEXT_ADD_CHILD] Target Node ID:', targetNodeId); // DEBUG
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const parentNode = nodes.find(n => n.id === targetNodeId);
            if (!parentNode) {
                showMessage('Nó pai não encontrado para adicionar filho.', 'error'); 
                return;
            }
            
            const childrenCount = parentNode.childrenIds.length;
            const angleStep = Math.PI / (childrenCount + 3); 
            const initialAngleOffset = -Math.PI / 2; 
            const baseDistance = (parentNode.isRoot ? 150 : 100) + childrenCount * 15; 
            const angle = initialAngleOffset + (childrenCount * angleStep) + (Math.random() * 0.2 - 0.1) ; 
            const childX = parentNode.x + parentNode.width / 2 - 50 + Math.cos(angle) * baseDistance;
            const childY = parentNode.y + parentNode.height / 2 - 20 + Math.sin(angle) * baseDistance;

            const newNode = createNode("Novo Filho", childX, childY, targetNodeId); 
            if (newNode) {
                selectedNodeId = newNode.id; 
                updateLines();
                renderMindMap(); 
                enterNodeTextEditMode(newNode.id); 
                showMessage(`Nó filho adicionado. Edite o texto.`, 'success');
            }
        });
        
        contextEditNodeBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            // console.log('[CONTEXT_EDIT_NODE] Target Node ID:', targetNodeId); // DEBUG
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const nodeToEdit = nodes.find(n => n.id === targetNodeId);
            if (nodeToEdit) {
                enterNodeTextEditMode(nodeToEdit.id);
            }
        });

        contextAddEditNoteBtn.addEventListener('click', () => { 
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            // console.log('[CONTEXT_ADD_EDIT_NOTE] Target Node ID:', targetNodeId); // DEBUG
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const nodeForNote = nodes.find(n => n.id === targetNodeId);
            if (nodeForNote) {
                openNotesPanel(nodeForNote.id);
            }
        });


        contextDeleteNodeBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            // console.log('[CONTEXT_DELETE_NODE] Target Node ID:', targetNodeId); // DEBUG
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) {
                return;
            }
            
            selectedNodeId = targetNodeId; 
            attemptDeleteSelectedNode();
        });
        
        window.addEventListener('click', (e) => {
            if (customContextMenu.style.display === 'block' && !customContextMenu.contains(e.target)) {
                hideCustomContextMenu();
            }
        });


        // --- Funções do Mapa Mental ---
        function showMessage(text, type = 'success', duration = 3000) {
            messageBox.textContent = text;
            messageBox.className = 'message-box'; 
            if (type === 'error') messageBox.classList.add('error');
            messageBox.style.display = 'block';
            setTimeout(() => { messageBox.style.display = 'none'; }, duration);
        }

        function createNode(text, x, y, parentId = null, isRoot = false) {
            const nodeText = text.trim(); 
            if (nodeText === "" && !isRoot) { 
                 showMessage('O texto do nó não pode estar vazio.', 'error');
                 return null;
            }
            const finalText = (isRoot && nodeText === "") ? "Nó Raiz" : nodeText; 

            const id = nextNodeId++;
            const nodeWidth = isRoot ? Math.max(200, finalText.length * 10 + 40) : Math.max(100, finalText.length * 8 + 30);
            const nodeHeight = isRoot ? 60 : 40; 

            const node = {
                id, text: finalText, x, y,
                width: nodeWidth, 
                height: nodeHeight,
                parentId, childrenIds: [], isRoot,
                notes: { 
                    text: '', 
                    imageUrl: '', 
                    documentName: ''
                }
            };
            nodes.push(node);
            if (parentId !== null) {
                const parentNodeFromArray = nodes.find(n => n.id === parentId);
                if (parentNodeFromArray) {
                     if (!parentNodeFromArray.childrenIds) parentNodeFromArray.childrenIds = []; 
                     parentNodeFromArray.childrenIds.push(id);
                }
            }
            return node;
        }
        
        function enterNodeTextEditMode(nodeId) {
            if (editingNodeTextId !== null && editingNodeTextId !== nodeId) { 
                 const currentlyEditingNode = nodes.find(n => n.id === editingNodeTextId);
                 if(currentlyEditingNode) {
                    const inputElement = document.getElementById(`node-edit-input-${editingNodeTextId}`);
                    if (inputElement) { 
                         currentlyEditingNode.text = inputElement.value.trim() || (currentlyEditingNode.isRoot ? "Nó Raiz" : "Nó"); 
                         currentlyEditingNode.width = currentlyEditingNode.isRoot ? Math.max(200, currentlyEditingNode.text.length * 10 + 40) : Math.max(100, currentlyEditingNode.text.length * 8 + 30);
                    }
                 }
            }
            editingNodeTextId = nodeId;
            renderMindMap(); 
        }

        function exitNodeTextEditMode(saveChanges) {
            if (editingNodeTextId === null) return;

            const node = nodes.find(n => n.id === editingNodeTextId);
            const inputElement = document.getElementById(`node-edit-input-${editingNodeTextId}`);

            if (node && inputElement) {
                if (saveChanges) {
                    const newText = inputElement.value.trim();
                    if (newText === "") { 
                        showMessage('O texto do nó não pode ficar vazio.', 'error');
                        inputElement.value = node.text; 
                        setTimeout(() => inputElement.focus(), 0); 
                        return; 
                    }
                    node.text = newText;
                    node.width = node.isRoot ? Math.max(200, node.text.length * 10 + 40) : Math.max(100, node.text.length * 8 + 30);
                    if (selectedNodeId === node.id) { 
                        selectedNodeDisplay.textContent = node.text;
                    }
                }
            }
            editingNodeTextId = null;
            updateLines();
            renderMindMap();
        }


        function renderMindMap() {
            svg.innerHTML = ''; 

            lines.forEach(lineData => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', lineData.pathString);
                path.classList.add('line');
                svg.appendChild(path);
            });

            nodes.forEach(node => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                group.dataset.id = node.id;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', node.width);
                rect.setAttribute('height', node.height);
                rect.setAttribute('rx', 8); rect.setAttribute('ry', 8);
                rect.classList.add('node');
                if (node.id === selectedNodeId && node.id !== editingNodeTextId) { 
                     rect.classList.add('selected');
                }
                group.appendChild(rect);

                if (node.id === editingNodeTextId) {
                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    foreignObject.setAttribute('x', 0);
                    foreignObject.setAttribute('y', 0);
                    foreignObject.setAttribute('width', node.width);
                    foreignObject.setAttribute('height', node.height);
                    
                    const inputBody = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');
                    inputBody.style.margin = '0'; 
                    inputBody.style.height = '100%';
                    inputBody.style.width = '100%';
                    inputBody.style.display = 'flex'; 
                    inputBody.style.alignItems = 'center';
                    inputBody.style.justifyContent = 'center';

                    const input = document.createElementNS('http://www.w3.org/1999/xhtml', 'input');
                    input.setAttribute('type', 'text');
                    input.setAttribute('value', node.text);
                    input.setAttribute('id', `node-edit-input-${node.id}`);
                    input.classList.add('node-edit-input'); 
                    if(node.isRoot) { 
                        input.classList.add('node-edit-input-root');
                    }
                    input.style.width = '90%'; 
                    input.style.height = 'calc(100% - 4px)'; 
                    input.style.lineHeight = `${node.height -4}px`;

                    input.addEventListener('blur', () => exitNodeTextEditMode(true));
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            exitNodeTextEditMode(true);
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            exitNodeTextEditMode(false);
                        }
                    });
                    
                    inputBody.appendChild(input);
                    foreignObject.appendChild(inputBody);
                    group.appendChild(foreignObject);

                    setTimeout(() => {
                        input.focus();
                        input.select();
                    }, 0);

                } else {
                    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('x', node.width / 2);
                    textElement.setAttribute('y', node.height / 2);
                    textElement.textContent = node.text;
                    textElement.classList.add('node-text');
                    if(node.isRoot) { 
                        textElement.classList.add('node-text-root');
                    }
                    group.appendChild(textElement);
                }

                const hasNoteContent = node.notes.text.trim() !== '' || node.notes.imageUrl.trim() !== '' || node.notes.documentName.trim() !== '';
                if (hasNoteContent && node.id !== editingNodeTextId) { 
                    const iconG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    iconG.innerHTML = noteIconSVG; 
                    const iconX = node.width - (node.isRoot ? 20 : 16); 
                    const iconY = node.isRoot ? 6 : 4;
                    iconG.setAttribute('transform', `translate(${iconX}, ${iconY})`);
                    iconG.classList.add('note-icon');
                    iconG.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        openNotesPanel(node.id);
                    });
                    group.appendChild(iconG);
                }
                
                svg.appendChild(group);
                group.addEventListener('mousedown', (e) => handleNodeMouseDown(e, node, group));
                group.addEventListener('click', (e) => handleNodeClick(e, node.id)); 
                group.addEventListener('dblclick', (e) => {
                    if (editingNodeTextId === node.id) return; 
                    e.stopPropagation();
                    enterNodeTextEditMode(node.id);
                });
                group.addEventListener('contextmenu', (e) => { 
                    e.preventDefault();
                    if (isInputFocused() || editingNodeTextId !== null || notesPanel.classList.contains('visible')) { 
                        return;
                    }
                    
                    selectedNodeId = node.id; 
                    // console.log('[CONTEXTMENU_EVENT] selectedNodeId set to:', selectedNodeId, 'for node text:', node.text); // DEBUG
                    
                    const currentSelectedNodeForDisplay = nodes.find(n => n.id === selectedNodeId);
                    if (currentSelectedNodeForDisplay) {
                        selectedNodeDisplay.textContent = currentSelectedNodeForDisplay.text;
                    }
                    
                    document.querySelectorAll('.node.selected').forEach(el => el.classList.remove('selected'));
                    const rectElement = group.querySelector('.node');
                    if (rectElement) rectElement.classList.add('selected');
                    
                    showCustomContextMenu(e.clientX, e.clientY, node.id);
                });
            });
            updateButtonStates();
        }

        function updateLines() {
            lines = []; 
            nodes.forEach(node => {
                if (node.parentId !== null) {
                    const parentNode = nodes.find(n => n.id === node.parentId);
                    const childNode = node; 
                    if (parentNode && childNode) {
                        const startX = parentNode.x + parentNode.width / 2;
                        const startY = parentNode.y + parentNode.height / 2;
                        const endX = childNode.x + childNode.width / 2;
                        const endY = childNode.y + childNode.height / 2;
                        const cp1x = startX + (endX - startX) * 0.5; 
                        const cp1y = startY;                         
                        const cp2x = startX + (endX - startX) * 0.5; 
                        const cp2y = endY;                         
                        const pathString = `M ${startX},${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
                        lines.push({ pathString: pathString });
                    }
                }
            });
        }

        function handleNodeClick(event, nodeId) { 
            // console.log('Node clicked. ID:', nodeId, 'Target:', event.target); // DEBUG
            if (event.target.closest('.note-icon') || event.target.closest('foreignObject')) {
                return; 
            }
            if (editingNodeTextId === nodeId) return; 

            event.stopPropagation(); 
            selectedNodeId = nodeId;
            const selectedNode = nodes.find(n => n.id === selectedNodeId);
            selectedNodeDisplay.textContent = selectedNode ? selectedNode.text : 'Nenhum';
            renderMindMap(); 
            hideCustomContextMenu(); 
        }

        function handleNodeMouseDown(event, node, element) {
            if (event.target.closest('.note-icon') || event.target.closest('foreignObject') || editingNodeTextId === node.id) {
                return; 
            }
            event.stopPropagation();
            if (event.button !== 0) return; 

            isDraggingNode = true;
            draggedNodeElement = element;
            const CTM = svg.getScreenCTM().inverse();
            const pt = svg.createSVGPoint();
            pt.x = event.clientX; pt.y = event.clientY;
            const svgP = pt.matrixTransform(CTM);
            dragOffsetX = svgP.x - node.x; dragOffsetY = svgP.y - node.y;
            draggedNodeElement.style.cursor = 'grabbing'; 
            hideCustomContextMenu(); 
        }

        svg.addEventListener('mousemove', (e) => {
            if (isDraggingNode && draggedNodeElement) {
                e.preventDefault();
                const CTM = svg.getScreenCTM().inverse();
                const pt = svg.createSVGPoint();
                pt.x = e.clientX; pt.y = e.clientY;
                const svgP = pt.matrixTransform(CTM);
                const nodeId = parseInt(draggedNodeElement.dataset.id);
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    node.x = svgP.x - dragOffsetX; node.y = svgP.y - dragOffsetY;
                    updateLines(); 
                    renderMindMap(); 
                }
            } else if (isPanning) {
                e.preventDefault();
                const dx = (e.clientX - lastPanPoint.x) * (viewBox.w / mindMapContainer.clientWidth);
                const dy = (e.clientY - lastPanPoint.y) * (viewBox.h / mindMapContainer.clientHeight);
                viewBox.x -= dx; viewBox.y -= dy;
                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                lastPanPoint = { x: e.clientX, y: e.clientY };
            }
        });
        
        window.addEventListener('mouseup', () => { 
            const previousIsDraggingNode = isDraggingNode;
            if (isDraggingNode) {
                if (draggedNodeElement) draggedNodeElement.style.cursor = 'grab';
                isDraggingNode = false;
            }
            if (isPanning) {
                isPanning = false;
                svg.style.cursor = 'default';
            }
            if (previousIsDraggingNode && !isDraggingNode) draggedNodeElement = null;
        });

        svg.addEventListener('mousedown', (e) => {
            if (editingNodeTextId !== null && !e.target.closest('foreignObject') && !e.target.closest('.node-edit-input')) {
                 exitNodeTextEditMode(true); 
            }

            if (e.target === svg || e.target === mindMapContainer) { 
                 if (e.button !== 0 && e.button !==2) return; 
                 if (e.button === 0) { 
                    isPanning = true;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    svg.style.cursor = 'move';
                 }
                if (selectedNodeId !== null && !isDraggingNode && editingNodeTextId === null) { 
                    selectedNodeId = null;
                    selectedNodeDisplay.textContent = 'Nenhum';
                    renderMindMap();
                }
                hideCustomContextMenu(); 
            }
        });
        svg.addEventListener('contextmenu', (e) => { 
            if (e.target === svg || e.target === mindMapContainer) {
                e.preventDefault();
                hideCustomContextMenu();
            }
        });


        mindMapContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const CTM = svg.getScreenCTM().inverse();
            const pt = svg.createSVGPoint();
            pt.x = e.clientX; pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM); 
            const dw = viewBox.w * Math.sign(e.deltaY) * zoomIntensity;
            const dh = viewBox.h * Math.sign(e.deltaY) * zoomIntensity;
            if (viewBox.w + dw > 50 && viewBox.h + dh > 50) { 
                viewBox.x -= dw * (svgP.x - viewBox.x) / viewBox.w;
                viewBox.y -= dh * (svgP.y - viewBox.y) / viewBox.h;
                viewBox.w += dw; viewBox.h += dh;
                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            }
            hideCustomContextMenu(); 
        });
        
        window.addEventListener('resize', () => {
            const containerWidth = mindMapContainer.clientWidth;
            const containerHeight = mindMapContainer.clientHeight;
            const centerX = viewBox.x + viewBox.w / 2;
            const centerY = viewBox.y + viewBox.h / 2;
            viewBox.w = containerWidth; viewBox.h = containerHeight;
            viewBox.x = centerX - viewBox.w / 2; viewBox.y = centerY - viewBox.h / 2;
            svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
        });

        function attemptDeleteSelectedNode() {
            // console.log('Attempting to delete node. Current selectedNodeId:', selectedNodeId); // DEBUG
            if (selectedNodeId === null) {
                showMessage('Nenhum nó selecionado para eliminar.', 'error');
                return;
            }
            const nodeToDelete = nodes.find(n => n.id === selectedNodeId);
            if (!nodeToDelete) {
                // console.error("attemptDeleteSelectedNode: Node with ID", selectedNodeId, "not found in nodes array:", nodes); // DEBUG
                showMessage('Erro: Nó a ser eliminado não encontrado.', 'error');
                return;
            }

            const confirmationText = `Tem a certeza que quer eliminar o nó "${nodeToDelete.text}"${nodeToDelete.childrenIds.length > 0 ? ' e todos os seus descendentes' : ''}?`;
            if (!window.confirm(confirmationText)) { 
                return;
            }
            
            let nodesToDeleteIds = [selectedNodeId];
            let queue = [...nodeToDelete.childrenIds];
            while(queue.length > 0) {
                const currentId = queue.shift();
                nodesToDeleteIds.push(currentId);
                const currentNode = nodes.find(n => n.id === currentId);
                if (currentNode) {
                    if (!currentNode.childrenIds) currentNode.childrenIds = []; 
                    queue.push(...currentNode.childrenIds);
                }
            }
            nodes = nodes.filter(n => !nodesToDeleteIds.includes(n.id));
            nodes.forEach(n => {
                if (!n.childrenIds) n.childrenIds = []; 
                n.childrenIds = n.childrenIds.filter(childId => !nodesToDeleteIds.includes(childId));
            });
            const oldSelectedText = nodeToDelete.text;
            if (editingNodeTextId === selectedNodeId) editingNodeTextId = null; 
            selectedNodeId = null; 
            selectedNodeDisplay.textContent = 'Nenhum';
            updateLines(); renderMindMap();
            showMessage(`Nó "${oldSelectedText}" e descendentes eliminados.`);
        }

        window.addEventListener('keydown', (e) => {
            // console.log('Keydown event:', e.key, 'selectedNodeId:', selectedNodeId, 'isInputFocused:', isInputFocused(), 'editingNodeTextId:', editingNodeTextId, 'notesPanelVisible:', notesPanel.classList.contains('visible'), 'contextMenuVisible:', customContextMenu.style.display); // DEBUG
            if (e.key === 'Delete') {
                if (selectedNodeId !== null && !isInputFocused() && editingNodeTextId === null && !notesPanel.classList.contains('visible') && customContextMenu.style.display === 'none') {
                    // console.log('Attempting delete via Delete key for node ID:', selectedNodeId); // DEBUG
                    attemptDeleteSelectedNode();
                }
            }
        });
        
        // Funções de Salvar e Abrir Mapa
        saveMapBtn.addEventListener('click', () => {
            if (nodes.length === 0) {
                showMessage('Não há nada para salvar. Adicione alguns nós primeiro.', 'error');
                return;
            }
            const mapData = {
                nodes: nodes,
                viewBox: viewBox,
                nextNodeId: nextNodeId 
            };
            const jsonData = JSON.stringify(mapData, null, 2); 
            const blob = new Blob([jsonData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mapa-mental.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('Mapa salvo com sucesso!', 'success');
        });

        openMapInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            if (file.type !== "application/json") {
                showMessage('Por favor, selecione um ficheiro .json válido.', 'error');
                event.target.value = null; 
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mapData = JSON.parse(e.target.result);
                    if (mapData && Array.isArray(mapData.nodes) && mapData.viewBox && typeof mapData.nextNodeId === 'number') {
                        nodes = [];
                        lines = [];
                        selectedNodeId = null;
                        editingNodeTextId = null;
                        
                        nodes = mapData.nodes;
                        viewBox = mapData.viewBox;
                        nextNodeId = mapData.nextNodeId;

                        nodes.forEach(n => {
                            if (!n.childrenIds) n.childrenIds = [];
                            if (!n.notes) { 
                                n.notes = { text: '', imageUrl: '', documentName: '' }; 
                            }
                        });


                        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                        updateLines();
                        renderMindMap();
                        showMessage('Mapa carregado com sucesso!', 'success');
                    } else {
                        showMessage('Ficheiro de mapa mental inválido ou corrompido.', 'error');
                    }
                } catch (error) {
                    showMessage('Erro ao ler o ficheiro do mapa mental: ' + error.message, 'error');
                } finally {
                    event.target.value = null; 
                }
            };
            reader.onerror = () => {
                showMessage('Erro ao ler o ficheiro.', 'error');
                event.target.value = null;
            };
            reader.readAsText(file);
        });


        function updateButtonStates() {
            const hasRootNode = nodes.some(n => n.isRoot);
            const nodeSelected = selectedNodeId !== null; 

            addNodeBtn.disabled = hasRootNode; 
            addChildBtn.disabled = !nodeSelected; 
            editNodeBtn.disabled = !nodeSelected;   
            deleteNodeBtn.disabled = !nodeSelected; 
            addEditNoteBtn.disabled = !nodeSelected; 
            saveMapBtn.disabled = nodes.length === 0; 
        }
        
        renderMindMap(); 
    </script>
</body>
</html>
