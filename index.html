<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa Mental Interativo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; 
            margin-top: 60px; /* Espaço para o menu superior fixo e título */
        }
        .node {
            cursor: grab;
            stroke: #333; 
            stroke-width: 1.5px;
            border-radius: 8px; 
        }
        .node-text {
            fill: #333; 
            text-anchor: middle; 
            dominant-baseline: middle; 
            pointer-events: none; 
            user-select: none; 
        }
        .node-text-root { 
            font-weight: bold;
        }
        .node.selected {
            stroke: #007bff; 
            stroke-width: 3px;
        }
        .line {
            stroke: #666; 
            stroke-width: 2px;
            fill: none; 
        }
        .note-icon {
            fill: #007bff;
            cursor: pointer;
            stroke: white;
            stroke-width: 0.5px;
        }
        .note-icon:hover {
            fill: #0056b3;
        }

        /* Título e Botão de Menu Lateral */
        .app-header-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            align-items: center;
            padding: 10px 20px;
            background-color: #f9f9f9; /* Cor de fundo para o cabeçalho */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1010; /* Acima do menu lateral */
        }
        #toggleMenuBtn {
            background-color: #007bff; 
            color: white; 
            border: none;
            border-radius: 8px; 
            padding: 8px; 
            cursor: pointer;
            display: flex; 
            align-items: center;
            justify-content: center;
            width: 40px; 
            height: 40px; 
            margin-right: 15px; 
        }
        #toggleMenuBtn:hover {
            background-color: #0056b3;
        }
        #toggleMenuBtn svg {
            width: 24px; 
            height: 24px;
        }
        .app-title-main {
            font-size: 1.25rem; /* Aumentado */
            font-weight: 600; /* Mais negrito */
            color: #333;
        }


        /* Painel de Comandos Lateral */
        .controls {
            position: fixed;
            top: 70px; 
            left: 20px;
            background-color: rgba(255, 255, 255, 0.95); 
            padding: 20px; 
            border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2); 
            z-index: 1000;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            width: 280px; 
        }
        .controls.hidden { 
            transform: translateX(-110%); 
            opacity: 0;
            pointer-events: none; 
        }

        .control-button, .file-input-label, .format-button, .color-option, .top-menu-button {
            background-color: #007bff;
            color: white;
            padding: 8px 12px; 
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            text-align: center;
        }
        .control-button, .file-input-label { 
             width: 100%; 
             display: block; 
        }
         .format-button, .color-option, .top-menu-button {
            margin-right: 5px;
            margin-bottom: 5px; 
            min-width: 30px; 
            height: 30px; 
            display: inline-flex; 
            align-items: center;
            justify-content: center;
        }
        .color-option {
            border: 1px solid #ccc; 
        }
        .top-menu-button svg {
            width: 18px;
            height: 18px;
        }
        .top-menu-button:disabled {
            background-color: #cccccc !important; /* Garante que o estilo desabilitado seja aplicado */
            cursor: not-allowed !important;
            opacity: 0.6;
        }


        .control-button:hover, .file-input-label:hover, .format-button:hover, .color-option:hover, .top-menu-button:not(:disabled):hover {
            background-color: #0056b3;
            opacity: 0.8;
        }
        .control-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .control-input {
            padding: 10px; 
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
            flex-grow: 1; 
        }
        .add-root-container {
            display: flex;
            align-items: center;
            margin-bottom: 15px; 
        }
        #addNodeBtnIcon { 
            background-color: #28a745; 
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin-left: 10px;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; 
        }
        #addNodeBtnIcon:hover {
            background-color: #218838;
        }
        #addNodeBtnIcon svg {
            width: 20px;
            height: 20px;
        }
        .menu-section label {
            display: block;
            text-sm font-medium text-gray-700 mb-1;
        }
        .menu-section select, .menu-section input[type="number"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }


        .message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 1001;
            display: none; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .message-box.error {
            background-color: #f44336; 
        }
        #mindMapContainer {
            width: 100%;
            height: calc(100vh - 60px); /* Ajustado para o cabeçalho fixo */
            overflow: hidden; 
            background-color: #f9f9f9; 
            position: relative;
            margin-top: 0; /* Reset margin-top do body */
        }
        #mindMapSvg {
            width: 100%;
            height: 100%;
            display: block;
        }
       
        /* Menu Superior Fixo */
        #topFixedMenu {
            position: fixed;
            top: 15px; /* Ajustado para ficar abaixo do título/botão de menu */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(240, 240, 240, 0.9);
            padding: 8px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            z-index: 1020;
            display: flex;
            gap: 10px; /* Espaço entre os botões */
        }


        /* Painel de Notas */
        #notesPanel {
            position: fixed;
            right: 0; 
            top: 0;
            width: 35%; 
            max-width: 500px; 
            min-width: 300px; 
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.1); 
            z-index: 1010; 
            transform: translateX(100%); 
            transition: transform 0.3s ease-in-out;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        #notesPanel.visible {
            transform: translateX(0); 
        }
        .notes-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #notesPanel h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #333;
            margin: 0; 
        }
        #closeNotesIcon {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
         #closeNotesIcon svg {
            width: 20px;
            height: 20px;
            stroke: #555;
        }
        #closeNotesIcon:hover svg {
            stroke: #000;
        }

        #noteTextArea { 
            width: 100%;
            flex-grow: 1; 
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Inter', sans-serif; 
            margin-bottom: 15px;
            resize: vertical; 
            min-height: 300px; 
        }
        .notes-toolbar {
            margin-bottom: 15px;
        }
        .notes-toolbar .format-controls { 
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            margin-bottom: 10px;
        }
        .notes-toolbar .format-controls label {
            margin-right: 10px;
            font-size: 0.875rem;
            color: #555;
        }
        .notes-toolbar input[type="number"] { 
            width: 70px; 
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.875rem;
        }
        .notes-actions { 
            margin-top: auto; 
            padding-top: 15px; 
            display: flex; 
            justify-content: flex-start; 
        }
        .notes-actions .control-button { 
            width: auto; 
            margin-right: 10px; 
        }


        .node-edit-input {
            width: 100%;
            height: 100%;
            border: none; 
            padding: 0;
            margin: 0;
            background: transparent;
            text-align: center;
            color: #333;
            outline: 1px solid #007bff; 
            box-sizing: border-box; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .node-edit-input-root { 
            font-weight: bold;
        }
        .custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1020; 
            display: none; 
        }
        .custom-context-menu-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .custom-context-menu-list li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .custom-context-menu-list li:hover {
            background-color: #f0f0f0;
        }
        #openMapInput {
            display: none;
        }

    </style>
</head>
<body>
    <div class="app-header-container">
        <button id="toggleMenuBtn" title="Alternar Menu"></button>
        <span class="app-title-main">App Mapa Mental</span> 
    </div>

    <div id="topFixedMenu">
        <button id="topAddChildBtn" class="top-menu-button" title="Criar Subtópico" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14m-7-7h14"/></svg>
        </button>
        <button id="topEditNodeBtn" class="top-menu-button" title="Editar Tópico" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
        </button>
        <button id="topAddEditNoteBtn" class="top-menu-button" title="Adicionar/Editar Nota" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>
        </button>
        <button id="topDeleteNodeBtn" class="top-menu-button" title="Deletar Tópico" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        </button>
    </div>


    <div id="mindMapContainer">
        <svg id="mindMapSvg"></svg>
    </div>

    <div id="controlsMenu" class="controls space-y-3"> 
        <div class="add-root-container">
            <input type="text" id="nodeText" class="control-input" placeholder="Tópico Principal">
            <button id="addNodeBtnIcon" title="Adicionar Tópico Principal">
                </button>
        </div>
        <hr class="my-2 border-gray-300">
        <div class="menu-section">
            <label class="block text-sm font-medium text-gray-700 mb-1">Cor:</label>
            <div id="nodeFillColorPalette" class="flex space-x-1 flex-wrap">
                </div>
        </div>
        <div class="menu-section">
            <label for="nodeFontFamilySelect" class="block text-sm font-medium text-gray-700 mb-1">Fonte:</label>
            <select id="nodeFontFamilySelect" class="control-input p-2 text-sm">
                <option value="Inter, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="Times New Roman, serif">Times New Roman</option>
                <option value="Courier New, monospace">Courier New</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="Comic Sans MS, cursive">Comic Sans MS</option>
            </select>
        </div>
        <div class="menu-section">
            <label for="nodeFontSizeInput" class="block text-sm font-medium text-gray-700 mb-1">Tamanho da Fonte:</label>
            <input type="number" id="nodeFontSizeInput" value="14" min="8" max="72" class="control-input p-2 text-sm">
        </div>

        <hr class="my-2 border-gray-300"> 
        <div>
            <button id="saveMapBtn" class="control-button bg-green-500 hover:bg-green-600">Salvar Mapa Mental</button>
        </div>
        <div>
            <input type="file" id="openMapInput" accept=".json">
            <label for="openMapInput" class="file-input-label bg-blue-500 hover:bg-blue-600">Abrir Mapa Mental</label>
        </div>
        <div>
            <button id="exportTxtBtn" class="control-button bg-orange-500 hover:bg-orange-600">Exportar Mapa (TXT)</button>
        </div>
        <hr class="my-2 border-gray-300"> 
        <div class="text-sm text-gray-700 pt-1"> 
            <span class="font-semibold">Tópico Selecionado:</span> <span id="selectedNodeDisplay" class="block mt-1 p-2 bg-gray-100 rounded">Nenhum</span> 
        </div>
        <div class="text-xs text-gray-500 pt-1"> 
            Clique duas vezes num tópico para editar o texto. <br>
            Clique com botão direito num tópico para mais opções. <br>
            Use o scroll do mouse para zoom. <br>Clique e arraste o fundo para mover.
        </div>
    </div>

    <div id="notesPanel">
        <div class="notes-panel-header">
            <h3>Editar Nota</h3> 
            <button id="closeNotesIcon" title="Fechar Painel de Notas">
                </button>
        </div>
        <div class="notes-toolbar">
            <div class="format-controls mb-2"> 
                <label for="notePanelFontSizeInput" class="mr-2">Tamanho da Fonte:</label>
                <input type="number" id="notePanelFontSizeInput" value="14" min="8" max="48" class="w-20 p-1 border border-gray-300 rounded text-sm">
            </div>
            <textarea id="noteTextArea" placeholder="Escreva as suas notas aqui..."></textarea>
        </div>
        <div class="notes-actions">
            <button id="exportNoteBtn" class="control-button bg-teal-500 hover:bg-teal-600">Exportar Nota (.txt)</button>
        </div>
    </div>

    <div id="messageBox" class="message-box">Mensagem</div>

    <div id="customContextMenu" class="custom-context-menu">
        <ul class="custom-context-menu-list">
            <li id="contextAddChild">Criar Subtópico</li>
            <li id="contextEditNode">Editar</li>
            <li id="contextAddEditNote">Adicionar/Editar Nota</li> 
            <li id="contextDeleteNode">Deletar</li>
        </ul>
    </div>


    <script>
        // --- Elementos da UI ---
        const svg = document.getElementById('mindMapSvg');
        const nodeTextInput = document.getElementById('nodeText'); 
        const addNodeBtnIcon = document.getElementById('addNodeBtnIcon'); 
        const selectedNodeDisplay = document.getElementById('selectedNodeDisplay');
        const messageBox = document.getElementById('messageBox');
        const mindMapContainer = document.getElementById('mindMapContainer');
        const toggleMenuBtn = document.getElementById('toggleMenuBtn');
        const controlsMenu = document.getElementById('controlsMenu');
        const saveMapBtn = document.getElementById('saveMapBtn'); 
        const openMapInput = document.getElementById('openMapInput'); 
        const exportTxtBtn = document.getElementById('exportTxtBtn');
        const nodeFillColorPalette = document.getElementById('nodeFillColorPalette');
        const nodeFontFamilySelect = document.getElementById('nodeFontFamilySelect');
        const nodeFontSizeInput = document.getElementById('nodeFontSizeInput');

        // Elementos do Menu Superior Fixo
        const topAddChildBtn = document.getElementById('topAddChildBtn');
        const topEditNodeBtn = document.getElementById('topEditNodeBtn');
        const topAddEditNoteBtn = document.getElementById('topAddEditNoteBtn');
        const topDeleteNodeBtn = document.getElementById('topDeleteNodeBtn');


        // Elementos do Painel de Notas
        const notesPanel = document.getElementById('notesPanel');
        const noteTextArea = document.getElementById('noteTextArea'); 
        const closeNotesIcon = document.getElementById('closeNotesIcon'); 
        const notePanelFontSizeInput = document.getElementById('notePanelFontSizeInput'); 
        const exportNoteBtn = document.getElementById('exportNoteBtn'); 

        let currentlyEditingNodeId = null; 
        let editingNodeTextId = null; 

        // Elementos do Menu de Contexto
        const customContextMenu = document.getElementById('customContextMenu');
        const contextAddChildBtn = document.getElementById('contextAddChild');
        const contextEditNodeBtn = document.getElementById('contextEditNode'); 
        const contextAddEditNoteBtn = document.getElementById('contextAddEditNote'); 
        const contextDeleteNodeBtn = document.getElementById('contextDeleteNode');


        // --- Ícones SVG ---
        const hamburgerIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
        const closeIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
        const noteIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="currentColor" class="note-indicator-icon"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>`;
        const panelCloseIconSVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
        const checkIconSVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;


        // --- Estado do Mapa Mental ---
        let nodes = [];
        let lines = []; 
        let selectedNodeId = null;
        let nextNodeId = 0;
        let isDraggingNode = false;
        let dragOffsetX, dragOffsetY;
        let draggedNodeElement = null;
        let viewBox = { x: 0, y: 0, w: mindMapContainer.clientWidth, h: mindMapContainer.clientHeight };
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        const defaultNodeFill = '#f0f0f0';
        const defaultNodeFontFamily = 'Inter, sans-serif';
        const defaultNodeFontSize = 14; 
        const rootNodeHeightFactor = 1.5; 
        const rootNodeFontSizeFactor = 1.5; 


        // --- Inicialização ---
        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
        toggleMenuBtn.innerHTML = hamburgerIconSVG; 
        closeNotesIcon.innerHTML = panelCloseIconSVG; 
        addNodeBtnIcon.innerHTML = checkIconSVG;

        // --- Cores para a Paleta ---
        const nodeFillColors = ['#FFCDD2', '#C8E6C9', '#BBDEFB', '#FFF9C4', '#D1C4E9', '#B2DFDB', '#f0f0f0'];

        function initializeColorPalette() {
            nodeFillColorPalette.innerHTML = ''; 
            nodeFillColors.forEach(color => {
                const colorDiv = document.createElement('div');
                colorDiv.classList.add('color-option');
                colorDiv.style.backgroundColor = color;
                colorDiv.dataset.color = color;
                colorDiv.title = `Mudar cor para ${color}`;
                colorDiv.addEventListener('click', () => {
                    if (selectedNodeId !== null) {
                        const node = nodes.find(n => n.id === selectedNodeId);
                        if (node) {
                            node.fill = color;
                            renderMindMap();
                        }
                    } else {
                        showMessage('Selecione um nó para mudar a cor.', 'error');
                    }
                });
                nodeFillColorPalette.appendChild(colorDiv);
            });
        }
        initializeColorPalette();


        // --- Funções Auxiliares ---
        function isInputFocused() {
            const activeElement = document.activeElement;
            if (!activeElement) return false;
            const tagName = activeElement.tagName.toLowerCase();
            return (tagName === 'input' || tagName === 'textarea' || activeElement.isContentEditable);
        }

        function sanitizeFilename(name) {
            return name.replace(/[^a-z0-9_\-\.]/gi, '_').replace(/\s+/g, '_').substring(0, 50);
        }

        // --- Event Listeners ---
        toggleMenuBtn.addEventListener('click', () => {
            controlsMenu.classList.toggle('hidden');
            toggleMenuBtn.innerHTML = controlsMenu.classList.contains('hidden') ? hamburgerIconSVG : closeIconSVG;
            toggleMenuBtn.title = controlsMenu.classList.contains('hidden') ? "Abrir Comandos" : "Fechar Comandos";
            hideCustomContextMenu(); 
        });
        
        addNodeBtnIcon.addEventListener('click', () => {
            const text = nodeTextInput.value.trim(); 
            if (nodes.some(n => n.isRoot)) {
                showMessage('Já existe um nó raiz.', 'error'); return;
            }
            const finalText = text === "" ? "Tópico Principal" : text; 

            const initialX = viewBox.x + viewBox.w / 2 - 100; 
            const initialY = viewBox.y + viewBox.h / 2 - 30; 
            const newNode = createNode(finalText, initialX, initialY, null, true); 
            if (newNode) {
                selectedNodeId = newNode.id; 
                nodeTextInput.value = ''; 
                if (document.activeElement === nodeTextInput) { 
                    nodeTextInput.blur(); 
                }
                updateLines(); 
                renderMindMap(); 
                showMessage(`Nó "${newNode.text}" adicionado como raiz.`);
            }
        });
        
        // Função para salvar dados da nota automaticamente
        function autoSaveNoteData() {
            if (currentlyEditingNodeId === null) return;
            const node = nodes.find(n => n.id === currentlyEditingNodeId);
            if (node) {
                const oldNoteEmpty = !node.notes.text; 

                node.notes.text = noteTextArea.value; 
                node.notes.noteFontSize = `${notePanelFontSizeInput.value}px`; 
                
                const newNoteEmpty = !node.notes.text.trim();

                if (oldNoteEmpty !== newNoteEmpty) {
                    renderMindMap(); 
                }
            }
        }

        // Funções do Painel de Notas
        noteTextArea.addEventListener('input', autoSaveNoteData); 
        notePanelFontSizeInput.addEventListener('input', () => { 
            noteTextArea.style.fontSize = `${notePanelFontSizeInput.value}px`;
            autoSaveNoteData();
        });


        exportNoteBtn.addEventListener('click', () => {
            if (currentlyEditingNodeId === null) {
                showMessage('Nenhuma nota aberta para exportar.', 'error');
                return;
            }
            const node = nodes.find(n => n.id === currentlyEditingNodeId);
            if (node && node.notes.text && node.notes.text.trim() !== "") {
                const textToSave = node.notes.text; 
                
                const blob = new Blob([textToSave], {type: 'text/plain;charset=utf-8'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const nodeNameForFile = sanitizeFilename(node.text) || 'nota';
                a.download = `${nodeNameForFile}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showMessage('Nota exportada com sucesso!', 'success');
            } else {
                showMessage('A nota está vazia, nada para exportar.', 'error');
            }
        });


        closeNotesIcon.addEventListener('click', closeNotesPanel); 

        function openNotesPanel(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            currentlyEditingNodeId = nodeId;
            noteTextArea.value = node.notes.text || ''; 
            notePanelFontSizeInput.value = parseInt(node.notes.noteFontSize) || 14; 
            noteTextArea.style.fontSize = node.notes.noteFontSize || '14px'; 
            notesPanel.classList.add('visible');
        }

        function closeNotesPanel() {
            notesPanel.classList.remove('visible');
            currentlyEditingNodeId = null;
        }

        // --- Funções do Menu de Contexto ---
        function showCustomContextMenu(x, y, nodeId) {
            customContextMenu.style.left = `${x}px`;
            customContextMenu.style.top = `${y}px`;
            customContextMenu.style.display = 'block';
            customContextMenu.dataset.targetNodeId = nodeId; 
        }

        function hideCustomContextMenu() {
            if (customContextMenu.style.display === 'block') {
                customContextMenu.style.display = 'none';
            }
        }

        contextAddChildBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const parentNode = nodes.find(n => n.id === targetNodeId);
            if (!parentNode) {
                showMessage('Nó pai não encontrado para adicionar filho.', 'error'); 
                return;
            }
            
            const childrenCount = parentNode.childrenIds.length;
            const angleStep = Math.PI / (childrenCount + 3); 
            const initialAngleOffset = -Math.PI / 2; 
            const baseDistance = (parentNode.isRoot ? 150 : 100) + childrenCount * 15; 
            const angle = initialAngleOffset + (childrenCount * angleStep) + (Math.random() * 0.2 - 0.1) ; 
            const childX = parentNode.x + parentNode.width / 2 - 50 + Math.cos(angle) * baseDistance;
            const childY = parentNode.y + parentNode.height / 2 - 20 + Math.sin(angle) * baseDistance;

            const newNode = createNode("Novo Filho", childX, childY, targetNodeId); 
            if (newNode) {
                selectedNodeId = newNode.id; 
                updateLines();
                renderMindMap(); 
                enterNodeTextEditMode(newNode.id); 
                showMessage(`Nó filho adicionado. Edite o texto.`, 'success');
            }
        });
        
        contextEditNodeBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const nodeToEdit = nodes.find(n => n.id === targetNodeId);
            if (nodeToEdit) {
                enterNodeTextEditMode(nodeToEdit.id);
            }
        });

        contextAddEditNoteBtn.addEventListener('click', () => { 
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) return;

            const nodeForNote = nodes.find(n => n.id === targetNodeId);
            if (nodeForNote) {
                openNotesPanel(nodeForNote.id);
            }
        });


        contextDeleteNodeBtn.addEventListener('click', () => {
            const targetNodeIdString = customContextMenu.dataset.targetNodeId;
            const targetNodeId = parseInt(targetNodeIdString);
            hideCustomContextMenu();
            if (isNaN(targetNodeId)) {
                return;
            }
            
            selectedNodeId = targetNodeId; 
            attemptDeleteSelectedNode();
        });
        
        window.addEventListener('click', (e) => {
            if (customContextMenu.style.display === 'block' && !customContextMenu.contains(e.target)) {
                hideCustomContextMenu();
            }
        });


        // --- Funções do Mapa Mental ---
        function showMessage(text, type = 'success', duration = 3000) {
            messageBox.textContent = text;
            messageBox.className = 'message-box'; 
            if (type === 'error') messageBox.classList.add('error');
            messageBox.style.display = 'block';
            setTimeout(() => { messageBox.style.display = 'none'; }, duration);
        }

        function createNode(text, x, y, parentId = null, isRoot = false) {
            const nodeText = text.trim(); 
            if (nodeText === "" && !isRoot) { 
                 showMessage('O texto do nó não pode estar vazio.', 'error');
                 return null;
            }
            const finalText = (isRoot && nodeText === "") ? "Tópico Principal" : nodeText; 

            const id = nextNodeId++;
            let currentFontSize = defaultNodeFontSize;
            if (isRoot) {
                currentFontSize = Math.round(defaultNodeFontSize * rootNodeFontSizeFactor);
            }

            const nodeWidth = isRoot ? Math.max(200, finalText.length * (currentFontSize * 0.6) + 40) : Math.max(100, finalText.length * (currentFontSize * 0.5) + 30);
            const nodeHeight = isRoot ? Math.round(defaultNodeFontSize * rootNodeHeightFactor * 2.5) : Math.round(defaultNodeFontSize * 2.8); 


            const node = {
                id, text: finalText, x, y,
                width: nodeWidth, 
                height: nodeHeight,
                parentId, childrenIds: [], isRoot,
                fill: defaultNodeFill, 
                fontFamily: defaultNodeFontFamily,
                fontSize: currentFontSize,
                notes: { 
                    text: '',
                    noteFontSize: '14px' 
                }
            };
            nodes.push(node);
            if (parentId !== null) {
                const parentNodeFromArray = nodes.find(n => n.id === parentId);
                if (parentNodeFromArray) {
                     if (!parentNodeFromArray.childrenIds) parentNodeFromArray.childrenIds = []; 
                     parentNodeFromArray.childrenIds.push(id);
                }
            }
            return node;
        }
        
        function enterNodeTextEditMode(nodeId) {
            if (editingNodeTextId !== null && editingNodeTextId !== nodeId) { 
                 const currentlyEditingNode = nodes.find(n => n.id === editingNodeTextId);
                 if(currentlyEditingNode) {
                    const inputElement = document.getElementById(`node-edit-input-${editingNodeTextId}`);
                    if (inputElement) { 
                         currentlyEditingNode.text = inputElement.value.trim() || (currentlyEditingNode.isRoot ? "Tópico Principal" : "Nó"); 
                         const currentFontSize = currentlyEditingNode.isRoot ? defaultNodeFontSize * rootNodeFontSizeFactor : currentlyEditingNode.fontSize;
                         currentlyEditingNode.width = currentlyEditingNode.isRoot ? Math.max(200, currentlyEditingNode.text.length * (currentFontSize * 0.6) + 40) : Math.max(100, currentlyEditingNode.text.length * (currentFontSize * 0.5) + 30);
                    }
                 }
            }
            editingNodeTextId = nodeId;
            renderMindMap(); 
        }

        function exitNodeTextEditMode(saveChanges) {
            if (editingNodeTextId === null) return;

            const node = nodes.find(n => n.id === editingNodeTextId);
            const inputElement = document.getElementById(`node-edit-input-${editingNodeTextId}`);

            if (node && inputElement) {
                if (saveChanges) {
                    const newText = inputElement.value.trim();
                    if (newText === "") { 
                        showMessage('O texto do nó não pode ficar vazio.', 'error');
                        inputElement.value = node.text; 
                        setTimeout(() => inputElement.focus(), 0); 
                        return; 
                    }
                    node.text = newText;
                    const currentFontSize = node.isRoot ? defaultNodeFontSize * rootNodeFontSizeFactor : node.fontSize;
                    node.width = node.isRoot ? Math.max(200, node.text.length * (currentFontSize * 0.6) + 40) : Math.max(100, node.text.length * (currentFontSize * 0.5) + 30);
                    if (selectedNodeId === node.id) { 
                        selectedNodeDisplay.textContent = node.text;
                    }
                }
            }
            editingNodeTextId = null;
            updateLines();
            renderMindMap();
        }


        function renderMindMap() {
            svg.innerHTML = ''; 

            lines.forEach(lineData => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', lineData.pathString);
                path.classList.add('line');
                svg.appendChild(path);
            });

            nodes.forEach(node => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                group.dataset.id = node.id;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', node.width);
                rect.setAttribute('height', node.height);
                rect.setAttribute('rx', 8); rect.setAttribute('ry', 8);
                rect.classList.add('node');
                rect.style.fill = node.fill || defaultNodeFill; 
                if (node.id === selectedNodeId && node.id !== editingNodeTextId) { 
                     rect.classList.add('selected');
                }
                group.appendChild(rect);

                if (node.id === editingNodeTextId) {
                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    foreignObject.setAttribute('x', 0);
                    foreignObject.setAttribute('y', 0);
                    foreignObject.setAttribute('width', node.width);
                    foreignObject.setAttribute('height', node.height);
                    
                    const inputBody = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');
                    inputBody.style.margin = '0'; 
                    inputBody.style.height = '100%';
                    inputBody.style.width = '100%';
                    inputBody.style.display = 'flex'; 
                    inputBody.style.alignItems = 'center';
                    inputBody.style.justifyContent = 'center';

                    const input = document.createElementNS('http://www.w3.org/1999/xhtml', 'input');
                    input.setAttribute('type', 'text');
                    input.setAttribute('value', node.text);
                    input.setAttribute('id', `node-edit-input-${node.id}`);
                    input.classList.add('node-edit-input'); 
                    input.style.fontFamily = node.fontFamily || defaultNodeFontFamily;
                    input.style.fontSize = `${node.fontSize || defaultNodeFontSize}px`;
                    if(node.isRoot) { 
                        input.classList.add('node-edit-input-root');
                        input.style.fontSize = `${Math.round(defaultNodeFontSize * rootNodeFontSizeFactor)}px`;
                    }
                    input.style.width = '90%'; 
                    input.style.height = 'calc(100% - 4px)'; 
                    input.style.lineHeight = `${node.height -4}px`;

                    input.addEventListener('blur', () => exitNodeTextEditMode(true));
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            exitNodeTextEditMode(true);
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            exitNodeTextEditMode(false);
                        }
                    });
                    
                    inputBody.appendChild(input);
                    foreignObject.appendChild(inputBody);
                    group.appendChild(foreignObject);

                    setTimeout(() => {
                        input.focus();
                        input.select();
                    }, 0);

                } else {
                    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    textElement.setAttribute('x', node.width / 2);
                    textElement.setAttribute('y', node.height / 2);
                    textElement.textContent = node.text;
                    textElement.classList.add('node-text');
                    textElement.style.fontFamily = node.fontFamily || defaultNodeFontFamily;
                    textElement.style.fontSize = `${node.fontSize || defaultNodeFontSize}px`;
                    if(node.isRoot) { 
                        textElement.classList.add('node-text-root');
                        textElement.style.fontSize = `${Math.round(defaultNodeFontSize * rootNodeFontSizeFactor)}px`;
                    }
                    group.appendChild(textElement);
                }

                const hasNoteContent = node.notes.text && node.notes.text.trim() !== ''; 
                if (hasNoteContent && node.id !== editingNodeTextId) { 
                    const iconG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    iconG.innerHTML = noteIconSVG; 
                    const iconX = node.width - (node.isRoot ? 20 : 16); 
                    const iconY = node.isRoot ? 6 : 4;
                    iconG.setAttribute('transform', `translate(${iconX}, ${iconY})`);
                    iconG.classList.add('note-icon');
                    iconG.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        openNotesPanel(node.id);
                    });
                    group.appendChild(iconG);
                }
                
                svg.appendChild(group);
                group.addEventListener('mousedown', (e) => handleNodeMouseDown(e, node, group));
                group.addEventListener('click', (e) => handleNodeClick(e, node.id)); 
                group.addEventListener('dblclick', (e) => {
                    if (editingNodeTextId === node.id) return; 
                    e.stopPropagation();
                    enterNodeTextEditMode(node.id);
                });
                group.addEventListener('contextmenu', (e) => { 
                    e.preventDefault();
                    if (isInputFocused() || editingNodeTextId !== null || notesPanel.classList.contains('visible')) { 
                        return;
                    }
                    
                    selectedNodeId = node.id; 
                    
                    const currentSelectedNodeForDisplay = nodes.find(n => n.id === selectedNodeId);
                    if (currentSelectedNodeForDisplay) {
                        selectedNodeDisplay.textContent = currentSelectedNodeForDisplay.text;
                        nodeFontFamilySelect.value = currentSelectedNodeForDisplay.fontFamily || defaultNodeFontFamily;
                        nodeFontSizeInput.value = currentSelectedNodeForDisplay.fontSize || defaultNodeFontSize;
                    }
                    
                    document.querySelectorAll('.node.selected').forEach(el => el.classList.remove('selected'));
                    const rectElement = group.querySelector('.node');
                    if (rectElement) rectElement.classList.add('selected');
                    
                    showCustomContextMenu(e.clientX, e.clientY, node.id);
                });
            });
            updateButtonStates();
        }

        function updateLines() {
            lines = []; 
            nodes.forEach(node => {
                if (node.parentId !== null) {
                    const parentNode = nodes.find(n => n.id === node.parentId);
                    const childNode = node; 
                    if (parentNode && childNode) {
                        const startX = parentNode.x + parentNode.width / 2;
                        const startY = parentNode.y + parentNode.height / 2;
                        const endX = childNode.x + childNode.width / 2;
                        const endY = childNode.y + childNode.height / 2;
                        const cp1x = startX + (endX - startX) * 0.5; 
                        const cp1y = startY;                         
                        const cp2x = startX + (endX - startX) * 0.5; 
                        const cp2y = endY;                         
                        const pathString = `M ${startX},${startY} C ${cp1x},${cp1y} ${cp2x},${cp2y} ${endX},${endY}`;
                        lines.push({ pathString: pathString });
                    }
                }
            });
        }

        function handleNodeClick(event, nodeId) { 
            if (event.target.closest('.note-icon') || event.target.closest('foreignObject')) {
                return; 
            }
            if (editingNodeTextId === nodeId) return; 

            event.stopPropagation(); 
            selectedNodeId = nodeId;
            const selectedNode = nodes.find(n => n.id === selectedNodeId);
            if (selectedNode) {
                selectedNodeDisplay.textContent = selectedNode.text;
                nodeFontFamilySelect.value = selectedNode.fontFamily || defaultNodeFontFamily;
                nodeFontSizeInput.value = selectedNode.fontSize || defaultNodeFontSize;
            } else {
                selectedNodeDisplay.textContent = 'Nenhum';
                nodeFontFamilySelect.value = defaultNodeFontFamily;
                nodeFontSizeInput.value = defaultNodeFontSize;
            }
            renderMindMap(); 
            hideCustomContextMenu(); 
        }

        function handleNodeMouseDown(event, node, element) {
            if (event.target.closest('.note-icon') || event.target.closest('foreignObject') || editingNodeTextId === node.id) {
                return; 
            }
            event.stopPropagation();
            if (event.button !== 0) return; 

            isDraggingNode = true;
            draggedNodeElement = element;
            const CTM = svg.getScreenCTM().inverse();
            const pt = svg.createSVGPoint();
            pt.x = event.clientX; pt.y = event.clientY;
            const svgP = pt.matrixTransform(CTM);
            dragOffsetX = svgP.x - node.x; dragOffsetY = svgP.y - node.y;
            draggedNodeElement.style.cursor = 'grabbing'; 
            hideCustomContextMenu(); 
        }

        svg.addEventListener('mousemove', (e) => {
            if (isDraggingNode && draggedNodeElement) {
                e.preventDefault();
                const CTM = svg.getScreenCTM().inverse();
                const pt = svg.createSVGPoint();
                pt.x = e.clientX; pt.y = e.clientY;
                const svgP = pt.matrixTransform(CTM);
                const nodeId = parseInt(draggedNodeElement.dataset.id);
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    node.x = svgP.x - dragOffsetX; node.y = svgP.y - dragOffsetY;
                    updateLines(); 
                    renderMindMap(); 
                }
            } else if (isPanning) {
                e.preventDefault();
                const dx = (e.clientX - lastPanPoint.x) * (viewBox.w / mindMapContainer.clientWidth);
                const dy = (e.clientY - lastPanPoint.y) * (viewBox.h / mindMapContainer.clientHeight);
                viewBox.x -= dx; viewBox.y -= dy;
                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                lastPanPoint = { x: e.clientX, y: e.clientY };
            }
        });
        
        window.addEventListener('mouseup', () => { 
            const previousIsDraggingNode = isDraggingNode;
            if (isDraggingNode) {
                if (draggedNodeElement) draggedNodeElement.style.cursor = 'grab';
                isDraggingNode = false;
            }
            if (isPanning) {
                isPanning = false;
                svg.style.cursor = 'default';
            }
            if (previousIsDraggingNode && !isDraggingNode) draggedNodeElement = null;
        });

        svg.addEventListener('mousedown', (e) => {
            if (editingNodeTextId !== null && !e.target.closest('foreignObject') && !e.target.closest('.node-edit-input')) {
                 exitNodeTextEditMode(true); 
            }

            if (e.target === svg || e.target === mindMapContainer) { 
                 if (e.button !== 0 && e.button !==2) return; 
                 if (e.button === 0) { 
                    isPanning = true;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    svg.style.cursor = 'move';
                 }
                if (selectedNodeId !== null && !isDraggingNode && editingNodeTextId === null) { 
                    selectedNodeId = null;
                    selectedNodeDisplay.textContent = 'Nenhum';
                    nodeFontFamilySelect.value = defaultNodeFontFamily; // Reset font controls
                    nodeFontSizeInput.value = defaultNodeFontSize;
                    renderMindMap();
                }
                hideCustomContextMenu(); 
            }
        });
        svg.addEventListener('contextmenu', (e) => { 
            if (e.target === svg || e.target === mindMapContainer) {
                e.preventDefault();
                hideCustomContextMenu();
            }
        });


        mindMapContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomIntensity = 0.1;
            const CTM = svg.getScreenCTM().inverse();
            const pt = svg.createSVGPoint();
            pt.x = e.clientX; pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM); 
            const dw = viewBox.w * Math.sign(e.deltaY) * zoomIntensity;
            const dh = viewBox.h * Math.sign(e.deltaY) * zoomIntensity;
            if (viewBox.w + dw > 50 && viewBox.h + dh > 50) { 
                viewBox.x -= dw * (svgP.x - viewBox.x) / viewBox.w;
                viewBox.y -= dh * (svgP.y - viewBox.y) / viewBox.h;
                viewBox.w += dw; viewBox.h += dh;
                svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
            }
            hideCustomContextMenu(); 
        });
        
        window.addEventListener('resize', () => {
            const containerWidth = mindMapContainer.clientWidth;
            const containerHeight = mindMapContainer.clientHeight;
            const centerX = viewBox.x + viewBox.w / 2;
            const centerY = viewBox.y + viewBox.h / 2;
            viewBox.w = containerWidth; viewBox.h = containerHeight;
            viewBox.x = centerX - viewBox.w / 2; viewBox.y = centerY - viewBox.h / 2;
            svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
        });

        function attemptDeleteSelectedNode() {
            if (selectedNodeId === null) {
                showMessage('Nenhum nó selecionado para eliminar.', 'error');
                return;
            }
            const nodeToDelete = nodes.find(n => n.id === selectedNodeId);
            if (!nodeToDelete) {
                return;
            }

            const confirmationText = `Tem a certeza que quer eliminar o nó "${nodeToDelete.text}"${nodeToDelete.childrenIds.length > 0 ? ' e todos os seus descendentes' : ''}?`;
            if (!window.confirm(confirmationText)) { 
                return;
            }
            
            let nodesToDeleteIds = [selectedNodeId];
            let queue = [...nodeToDelete.childrenIds];
            while(queue.length > 0) {
                const currentId = queue.shift();
                nodesToDeleteIds.push(currentId);
                const currentNode = nodes.find(n => n.id === currentId);
                if (currentNode) {
                    if (!currentNode.childrenIds) currentNode.childrenIds = []; 
                    queue.push(...currentNode.childrenIds);
                }
            }
            nodes = nodes.filter(n => !nodesToDeleteIds.includes(n.id));
            nodes.forEach(n => {
                if (!n.childrenIds) n.childrenIds = []; 
                n.childrenIds = n.childrenIds.filter(childId => !nodesToDeleteIds.includes(childId));
            });
            const oldSelectedText = nodeToDelete.text;
            if (editingNodeTextId === selectedNodeId) editingNodeTextId = null; 
            selectedNodeId = null; 
            selectedNodeDisplay.textContent = 'Nenhum';
            nodeFontFamilySelect.value = defaultNodeFontFamily; // Reset font controls
            nodeFontSizeInput.value = defaultNodeFontSize;
            updateLines(); renderMindMap();
            showMessage(`Nó "${oldSelectedText}" e descendentes eliminados.`);
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete') {
                if (selectedNodeId !== null && !isInputFocused() && editingNodeTextId === null && !notesPanel.classList.contains('visible') && customContextMenu.style.display === 'none') {
                    attemptDeleteSelectedNode();
                }
            }
        });
        
        // Listeners para os controlos de fonte do nó
        nodeFontFamilySelect.addEventListener('change', (e) => {
            if (selectedNodeId !== null) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.fontFamily = e.target.value;
                    renderMindMap();
                }
            }
        });

        nodeFontSizeInput.addEventListener('input', (e) => {
            if (selectedNodeId !== null) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    const newSize = parseInt(e.target.value);
                    if (newSize >= 8 && newSize <= 72) {
                         node.fontSize = newSize;
                         const currentFontSize = node.isRoot ? Math.round(defaultNodeFontSize * rootNodeFontSizeFactor) : node.fontSize; 
                         node.width = node.isRoot ? Math.max(200, node.text.length * (currentFontSize * 0.6) + 40) : Math.max(100, node.text.length * (currentFontSize * 0.5) + 30);
                         node.height = node.isRoot ? Math.round(defaultNodeFontSize * rootNodeHeightFactor * 2.5) : Math.round(defaultNodeFontSize * 2.8);
                         renderMindMap();
                    }
                }
            }
        });


        // Funções de Salvar e Abrir Mapa
        saveMapBtn.addEventListener('click', () => {
            if (nodes.length === 0) {
                showMessage('Não há nada para salvar. Adicione alguns nós primeiro.', 'error');
                return;
            }
            const rootNode = nodes.find(n => n.isRoot);
            const fileNameBase = rootNode ? sanitizeFilename(rootNode.text) : 'mapa-mental';

            const mapData = {
                nodes: nodes,
                viewBox: viewBox,
                nextNodeId: nextNodeId 
            };
            const jsonData = JSON.stringify(mapData, null, 2); 
            const blob = new Blob([jsonData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileNameBase}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('Mapa salvo com sucesso!', 'success');
        });

        openMapInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            if (file.type !== "application/json") {
                showMessage('Por favor, selecione um ficheiro .json válido.', 'error');
                event.target.value = null; 
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const mapData = JSON.parse(e.target.result);
                    if (mapData && Array.isArray(mapData.nodes) && mapData.viewBox && typeof mapData.nextNodeId === 'number') {
                        nodes = [];
                        lines = [];
                        selectedNodeId = null;
                        editingNodeTextId = null;
                        
                        nodes = mapData.nodes;
                        viewBox = mapData.viewBox;
                        nextNodeId = mapData.nextNodeId;

                        nodes.forEach(n => { 
                            if (!n.childrenIds) n.childrenIds = [];
                            if (!n.fill) n.fill = defaultNodeFill;
                            if (!n.fontFamily) n.fontFamily = defaultNodeFontFamily;
                            if (!n.fontSize) n.fontSize = defaultNodeFontSize;
                            if (n.isRoot) { 
                                n.fontSize = Math.round(defaultNodeFontSize * rootNodeFontSizeFactor);
                                n.height = Math.round(defaultNodeFontSize * rootNodeHeightFactor * 2.5);
                            }
                            if (!n.notes) { 
                                n.notes = { text: '', noteFontSize: '14px' }; 
                            } else if (!n.notes.noteFontSize) { 
                                n.notes.noteFontSize = '14px';
                            }
                        });


                        svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
                        updateLines();
                        renderMindMap();
                        showMessage('Mapa carregado com sucesso!', 'success');
                    } else {
                        showMessage('Ficheiro de mapa mental inválido ou corrompido.', 'error');
                    }
                } catch (error) {
                    showMessage('Erro ao ler o ficheiro do mapa mental: ' + error.message, 'error');
                } finally {
                    event.target.value = null; 
                }
            };
            reader.onerror = () => {
                showMessage('Erro ao ler o ficheiro.', 'error');
                event.target.value = null;
            };
            reader.readAsText(file);
        });

        exportTxtBtn.addEventListener('click', () => {
            if (nodes.length === 0) {
                showMessage('Não há nada para exportar.', 'error');
                return;
            }

            let output = "Mapa Mental Exportado:\n\n";
            const rootNode = nodes.find(n => n.isRoot);
            const fileNameBase = rootNode ? sanitizeFilename(rootNode.text) : 'mapa-mental';


            function getNodeTextForExport(nodeId, indentLevel, prefix) {
                const node = nodes.find(n => n.id === nodeId);
                if (!node) return "";

                let nodeOutput = "";
                const indent = "  ".repeat(indentLevel); 

                nodeOutput += `${indent}${prefix} ${node.text}\n`; 

                if (node.notes && node.notes.text && node.notes.text.trim() !== "") {
                    nodeOutput += `\n${indent}  Nota:\n`; 
                    const noteLines = node.notes.text.split('\n');
                    noteLines.forEach(line => {
                        nodeOutput += `${indent}    ${line}\n`; 
                    });
                }
                nodeOutput += `\n`; 
                
                if (node.childrenIds && node.childrenIds.length > 0) {
                    node.childrenIds.forEach((childId, index) => {
                        nodeOutput += getNodeTextForExport(childId, indentLevel + 1, `${prefix}${index + 1}.`);
                    });
                }
                return nodeOutput;
            }

            if (rootNode) {
                output += getNodeTextForExport(rootNode.id, 0, "1.");
            } else { 
                let count = 1;
                nodes.forEach(node => { 
                     if (node.parentId === null) { 
                        output += getNodeTextForExport(node.id, 0, `${count}.`);
                        count++;
                    }
                });
            }
            
            const blob = new Blob([output], {type: 'text/plain;charset=utf-8'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileNameBase}-mapa.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('Mapa exportado como TXT!', 'success');
        });


        function updateButtonStates() {
            const hasRootNode = nodes.some(n => n.isRoot);
            addNodeBtnIcon.disabled = hasRootNode; 
            saveMapBtn.disabled = nodes.length === 0; 
            exportTxtBtn.disabled = nodes.length === 0;

            const nodeSelected = selectedNodeId !== null;
            nodeFontFamilySelect.disabled = !nodeSelected;
            nodeFontSizeInput.disabled = !nodeSelected;
            nodeFillColorPalette.querySelectorAll('.color-option').forEach(opt => {
                opt.style.opacity = nodeSelected ? '1' : '0.5';
                opt.style.cursor = nodeSelected ? 'pointer' : 'not-allowed';
            });
        }
        
        renderMindMap(); 
    </script>
</body>
</html>
